#!/bin/bash
# Generated by CHARMM-GUI (http://www.charmm-gui.org) v3.7

# Function to expand a CPU list (e.g., "1-2,20-21,42-45") into an array of individual cores
expand_cpu_list() {
    local list="$1"
    local expanded=()
    IFS=',' read -ra ranges <<< "$list"
    for range in "${ranges[@]}"; do
        if [[ "$range" == *"-"* ]]; then
            IFS='-' read -r start end <<< "$range"
            for (( i=start; i<=end; i++ )); do
                expanded+=("$i")
            done
        else
            expanded+=("$range")
        fi
    done
    echo "${expanded[@]}"
}

# Try to get allocated CPU IDs from "thisjob" output
cpu_ids=$(thisjob | grep CPU_IDs | sed -E 's/.*CPU_IDs=([^ ]+).*/\1/')
if [[ -n "$cpu_ids" ]]; then
    echo "Using CPU_IDs from thisjob: $cpu_ids"
    allocated=($(expand_cpu_list "$cpu_ids"))
else
    # Fallback: Ensure SLURM_JOB_CPUS_LIST is set
    if [[ -z "$SLURM_JOB_CPUS_LIST" ]]; then
        echo "SLURM_JOB_CPUS_LIST is not set."
        exit 1
    fi
    allocated=($(expand_cpu_list "$SLURM_JOB_CPUS_LIST"))
fi

# Input parameters
# Usage: ./script.sh <NAMD_CORES> <GPU_DEVICE> <n_runs>
NAMD_CORES="$1"    # Number of cores for NAMD
GPU_DEVICE="$2"    # GPU device to use
n_runs="$3"        # Number of runs
PYTHON_CORES=0

# Check if enough cores are allocated
total_allocated=${#allocated[@]}
required=$((NAMD_CORES + PYTHON_CORES))
if (( total_allocated < required )); then
    echo "Not enough allocated cores. Allocated: $total_allocated, Required: $required"
    exit 1
fi

# Get the list for NAMD cores (first NAMD_CORES from allocated list)
namd_cores_array=("${allocated[@]:0:NAMD_CORES}")
namd_core_list=$(IFS=, ; echo "${namd_cores_array[*]}")

# Variables for file names and paths
equi_prefix="step4_equilibration"
prod_prefix="step5_production_vanilla"
prod_step="step5_vanilla_${NAMD_CORES}"
namd="bin/namd3_vanilla_gpu_mc"

echo "Running production for $n_runs runs with NAMD core list: $namd_core_list and GPU device: $GPU_DEVICE"

# Running production for 10 nanoseconds (cntmax=1 for simplicity)
cntmax=1

for run in $(seq 1 "$n_runs"); do
    # Create output directory only if it doesn't exist
    if [[ ! -d "output/run-${run}" ]]; then
        mkdir -p "output/run-${run}"
    fi

    cnt=1
    while [[ $cnt -le $cntmax ]]; do
        if [[ $cnt -eq 1 ]]; then
            outputname="${prod_step}_${cnt}"
            sed "s/${prod_prefix}/${outputname}/" "input/${prod_prefix}.inp" > "input/${prod_step}_run.inp"
            sed -i "0,/output\//s//output\/run-${run}\//" "input/${prod_step}_run.inp"
        else
            cntprev=$((cnt - 1))
            inputname="${prod_step}_${cntprev}"
            outputname="${prod_step}_${cnt}"
            sed "s/${equi_prefix}/${inputname}/" "input/${prod_prefix}.inp" | \
                sed "s/${prod_prefix}/${outputname}/" > "input/${prod_step}_run.inp"
            sed -i "s|output/|output/run-${run}/|g" "input/${prod_step}_run.inp"
        fi

        # Run the simulation for 1 nanosecond with dynamic taskset cores
        taskset -c "$namd_core_list" ./"$namd" +p"$NAMD_CORES" +devices "$GPU_DEVICE" "input/${prod_step}_run.inp" > "output/run-${run}/${outputname}.out" &
        wait

        cnt=$((cnt + 1))
    done
done

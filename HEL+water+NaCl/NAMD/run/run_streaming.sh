#!/bin/bash
# Generated by CHARMM-GUI (http://www.charmm-gui.org) v3.7

# Function to expand a CPU list (e.g., "1-2,20-21,42-45") into an array of individual cores
expand_cpu_list() {
    local list="$1"
    local expanded=()
    IFS=',' read -ra ranges <<< "$list"
    for range in "${ranges[@]}"; do
        if [[ "$range" == *"-"* ]]; then
            IFS='-' read -r start end <<< "$range"
            for (( i=start; i<=end; i++ )); do
                expanded+=("$i")
            done
        else
            expanded+=("$range")
        fi
    done
    echo "${expanded[@]}"
}

# Try to get allocated CPU IDs from "thisjob" output
cpu_ids=$(thisjob | grep CPU_IDs | sed -E 's/.*CPU_IDs=([^ ]+).*/\1/')
if [[ -n "$cpu_ids" ]]; then
    echo "Using CPU_IDs from thisjob: $cpu_ids"
    allocated=($(expand_cpu_list "$cpu_ids"))
else
    # Fallback: Ensure SLURM_JOB_CPUS_LIST is set
    if [[ -z "$SLURM_JOB_CPUS_LIST" ]]; then
        echo "SLURM_JOB_CPUS_LIST is not set."
        exit 1
    fi
    allocated=($(expand_cpu_list "$SLURM_JOB_CPUS_LIST"))
fi

# Input parameters
# Usage: ./script.sh <NAMD_CORES> <GPU_DEVICE> <PYTHON_CORES> <n_runs>
NAMD_CORES="$1"    # Number of cores for NAMD
GPU_DEVICE="$2"    # GPU device to use
PYTHON_CORES="$3"  # Number of CPU cores for client.py
n_runs="$4"        # Number of runs
pos_freq="$5"    # Frequency for position output
vel_freq="$6"    # Frequency for velocity output
force_freq="$7"  # Frequency for force output
box_freq="$8"   # Frequency for box output
typeprod="$9"      # Type of production (optimization or other)

# maximum frequency of pos_freq, vel_freq, force_freq, box_freq
imd_freq=$(( pos_freq > vel_freq ? (pos_freq > force_freq ? (pos_freq > box_freq ? pos_freq : box_freq) : (force_freq > box_freq ? force_freq : box_freq)) : (vel_freq > force_freq ? (vel_freq > box_freq ? vel_freq : box_freq) : (force_freq > box_freq ? force_freq : box_freq)) ))
# if pos_freq > 0 "yes", else "no" for send_positions
if (( pos_freq > 0 )); then
    send_positions="yes"
else
    send_positions="no"
fi
# if vel_freq > 0 "yes", else "no" for send_velocities
if (( vel_freq > 0 )); then
    send_velocities="yes"
else
    send_velocities="no"
fi
# if force_freq > 0 "yes", else "no" for send_forces
if (( force_freq > 0 )); then
    send_forces="yes"
else
    send_forces="no"
fi
# if box_freq > 0 "yes", else "no" for send_box_dimensions
if (( box_freq > 0 )); then
    send_box_dimensions="yes"
else
    send_box_dimensions="no"
fi


# Check if enough cores are allocated
total_allocated=${#allocated[@]}
required=$((NAMD_CORES + PYTHON_CORES))
if (( total_allocated < required )); then
    echo "Not enough allocated cores. Allocated: $total_allocated, Required: $required"
    exit 1
fi

# Get the lists for NAMD and Python
namd_cores_array=("${allocated[@]:0:NAMD_CORES}")
python_cores_array=("${allocated[@]:NAMD_CORES:PYTHON_CORES}")

# Convert arrays to comma-separated strings for taskset
namd_core_list=$(IFS=, ; echo "${namd_cores_array[*]}")
python_core_list=$(IFS=, ; echo "${python_cores_array[*]}")

# Variables for file names and paths
equi_prefix="step4_equilibration"
prod_prefix="step5_production_streaming"
prod_step="step5_streaming"
namd="bin/namd3_IMDv3_gpu_mc"
output_dir="output/streaming/${typeprod}/1-1-${NAMD_CORES}/pos-${pos_freq}_vel-${vel_freq}_force-${force_freq}_box-${box_freq}"
equi_dir="output/vanilla/performance/1-1-40/run-1"

# Running production for 10 nanoseconds (cntmax=1 for simplicity)
cntmax=1

for run in $(seq 1 "$n_runs"); do
    # Create output directory only if it doesn't exist
    if [[ ! -d "${output_dir}/run-${run}" ]]; then
        mkdir -p "${output_dir}/run-${run}"
    fi

    cnt=1
    while [[ $cnt -le $cntmax ]]; do
        if [[ $cnt -eq 1 ]]; then
            outputname="${prod_step}_${cnt}"
            sed "s/${prod_prefix}/${outputname}/" "input/${prod_prefix}.inp" > "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "0,/${outputname}\//s//${output_dir}\/run-${run}\/${outputname}\//" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "0,/${equi_prefix}\//s//${equi_dir}\/${equi_prefix}\//" "${output_dir}/run-${run}/${prod_step}_run.inp"
            # sed -i "0,/${output_dir}\//s//${output_dir}\/run-${run}\//" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "s/imd_frequency/${imd_freq}/g" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "s/send_positions/${send_positions}/g" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "s/send_velocities/${send_velocities}/g" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "s/send_forces/${send_forces}/g" "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "s/send_box_dimensions/${send_box_dimensions}/g" "${output_dir}/run-${run}/${prod_step}_run.inp"
        else
            cntprev=$((cnt - 1))
            inputname="${prod_step}_${cntprev}"
            outputname="${prod_step}_${cnt}"
            # sed "s/${equi_prefix}/${inputname}/" "input/${prod_prefix}.inp" | \
            #     sed "s/${prod_prefix}/${outputname}/" > "input/${prod_step}_run.inp"
            sed "s/${inputname}/${outputname}/" "${output_dir}/run-${run}/${prod_step}_run.inp" > "${output_dir}/run-${run}/${prod_step}_run.inp"
            sed -i "0,/${equi_dir}\/${equi_prefix}\//s//${output_dir}\/run-${run}\/${inputname}\//" "${output_dir}/run-${run}/${prod_step}_run.inp"

            # sed -i "s|${output_dir}/|${output_dir}/run-${run}/|g" "input/${prod_step}_run.inp"
        fi

        # Run the simulation for 1 nanosecond with dynamic taskset cores
        # taskset -c "$namd_core_list" ./"$namd" +p"$NAMD_CORES" +devices "$GPU_DEVICE" "input/${prod_step}_run.inp" > "${output_dir}/run-${run}/${outputname}.out" &
        taskset -c "$namd_core_list" ./"$namd" +p"$NAMD_CORES" +devices "$GPU_DEVICE" "${output_dir}/run-${run}/${prod_step}_run.inp" > "${output_dir}/run-${run}/${outputname}.out" &
        sleep 2
        # Run the client process on the allocated Python cores
        taskset -c "$python_core_list" python3.11 input/IMDv3-client.py "${output_dir}/run-${run}" &
        wait

        cnt=$((cnt + 1))
    done
done
